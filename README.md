# chibicc-for-rust

本工程是我学习 Rust 的练手项目，旨在模仿 chibicc 的整体思路，实现一个更强类型、更安全的 C 子集编译器。当前实现以教学/实践为主，聚焦词法分析、语法分析、AST 构建与 x86-64 汇编生成。

**当前状态**：可将一段 C 子集源码编译为 x86-64 Intel 语法汇编并输出到 stdout。

**目标与动机**
1. 用 Rust 的类型系统组织编译器核心数据结构。
2. 跟随 chibicc 的“从零实现”路线，逐步扩展语言特性。
3. 保持实现简单、可读、便于学习与迭代。

**支持的语法（已实现）**
1. 整数字面量与标识符（局部变量在首次使用时加入局部表）
2. 二元运算：`+` `-` `*` `/`
3. 比较运算：`==` `!=` `<` `<=` `>` `>=`
4. 一元运算：`+` `-`
5. 赋值表达式：`a = expr`
6. 语句：表达式语句、`return`、`if/else`、`while`、`for`、复合语句 `{ ... }`

**不支持（待实现）**
1. 类型系统与变量声明
2. 函数定义/调用、参数与返回类型
3. 指针、数组、结构体、全局变量等
4. 预处理与多文件编译
5. 完整的错误恢复与多行源码定位

**快速开始**
1. 构建与运行（输出汇编）

```powershell
cargo run -- "a=3; return a+5;"
```

2. 将汇编输出到文件并链接运行（需要 `clang`）

```powershell
cargo run -- "a=3; return a+5;" > tmp.s
clang -o out.exe tmp.s
.\out.exe
```

**测试**
项目内置了简单的端到端测试（`src/assembler.rs`），通过 `cargo test` 驱动：

```powershell
cargo test
```

注意：测试会写入 `tmp.s` 并调用 `clang` 生成 `D:\tmp.exe`。如果你的环境不在 Windows 或路径不可用，请在 `src/assembler.rs` 中调整输出路径。

**项目结构**
1. `src/tokenizer.rs`：词法分析
2. `src/parser/mod.rs`：语法分析与 AST 构建
3. `src/ast/mod.rs`：AST 定义
4. `src/codegen/mod.rs`：x86-64 汇编生成
5. `src/error_handler.rs`：基础错误报告
6. `src/assembler.rs`：测试用汇编生成与运行辅助

**路线图（可能的下一步）**
1. 引入类型系统（`int`/`long` 等）与变量声明
2. 函数定义与调用、参数传递
3. 指针/数组、字符串字面量
4. 更完整的错误诊断（行号/列号、多行源码）
5. 更完善的测试与基准

**致谢**
灵感来源于 chibicc：一个极简、可读性很强的 C 编译器实现。
